!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.suisdk=t():e.suisdk=t()}(self,(()=>(()=>{var e={364:e=>{"use strict";e.exports=function(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(255!==t[s])throw new TypeError(i+" is ambiguous");t[s]=n}var a=e.length,o=e.charAt(0),c=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;for(var r=0,n=0,i=0;e[r]===o;)n++,r++;for(var s=(e.length-r)*c+1>>>0,u=new Uint8Array(s);e[r];){var d=t[e.charCodeAt(r)];if(255===d)return;for(var l=0,h=s-1;(0!==d||l<i)&&-1!==h;h--,l++)d+=a*u[h]>>>0,u[h]=d%256>>>0,d=d/256>>>0;if(0!==d)throw new Error("Non-zero carry");i=l,r++}for(var p=s-i;p!==s&&0===u[p];)p++;for(var f=new Uint8Array(n+(s-p)),m=n;p!==s;)f[m++]=u[p++];return f}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,i=0,s=t.length;i!==s&&0===t[i];)i++,r++;for(var c=(s-i)*u+1>>>0,d=new Uint8Array(c);i!==s;){for(var l=t[i],h=0,p=c-1;(0!==l||h<n)&&-1!==p;p--,h++)l+=256*d[p]>>>0,d[p]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=h,i++}for(var f=c-n;f!==c&&0===d[f];)f++;for(var m=o.repeat(r);f<c;++f)m+=e.charAt(d[f]);return m},decodeUnsafe:d,decode:function(e){var t=d(e);if(t)return t;throw new Error("Non-base"+a+" character")}}}},763:(e,t,r)=>{const n=r(364);e.exports=n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{"use strict";function e(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}r.r(n),r.d(n,{GetSuiClient:()=>lr});const t=8192;function i(e){if(e.length<t)return btoa(String.fromCharCode(...e));let r="";for(var n=0;n<e.length;n+=t){const i=e.slice(n,n+t);r+=String.fromCharCode(...i)}return btoa(r)}var s=r(763);const a=e=>s.encode(e),o=e=>s.decode(e);function c(e){const t=e.startsWith("0x")?e.slice(2):e,r=t.length%2==0?t:`0${t}}`,n=r.match(/.{2}/g)?.map((e=>parseInt(e,16)))??[];return Uint8Array.from(n)}function u(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}function d(e){let t=[],r=0;if(0===e)return[0];for(;e>0;)t[r]=127&e,(e>>=7)&&(t[r]|=128),r+=1;return t}class l{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),t=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+t).toString(10)}read128(){let e=BigInt(this.read64()),t=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+t).toString(10)}read256(){let e=BigInt(this.read128()),t=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+t).toString(10)}readBytes(e){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:n}=function(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(127&i)<<r,!(128&i))break;r+=7}return{value:t,length:n}}(t);return this.shift(n),r}readVec(e){let t=this.readULEB(),r=[];for(let n=0;n<t;n++)r.push(e(this,n,t));return r}}function h(e,t=["<",">"]){const[r,n]=t,i=[];let s="",a=0;for(let t=0;t<e.length;t++){const o=e[t];o===r&&a++,o===n&&a--,0!==a||","!==o?s+=o:(i.push(s.trim()),s="")}return i.push(s.trim()),i}class p{constructor({size:e=1024,maxSize:t,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=t||e,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const e=Math.min(this.maxSize,this.size+this.allocateSize);if(t>e)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=e;const r=new ArrayBuffer(this.size);new Uint8Array(r).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(r)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return f(BigInt(e),8).forEach((e=>this.write8(e))),this}write128(e){return f(BigInt(e),16).forEach((e=>this.write8(e))),this}write256(e){return f(BigInt(e),32).forEach((e=>this.write8(e))),this}writeULEB(e){return d(e).forEach((e=>this.write8(e))),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach(((r,n)=>t(this,r,n,e.length))),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return function(e,t){switch(t){case"base58":return a(e);case"base64":return i(e);case"hex":return u(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(this.toBytes(),e)}}function f(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e/=BigInt(256),n+=1;return r}var m,y,g,w,b=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},v=(e,t,r)=>(b(e,t,"read from private field"),r?r.call(e):t.get(e)),S=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},T=(e,t,r,n)=>(b(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r);const E=class{constructor(e){S(this,m,void 0),S(this,y,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),T(this,m,e.write),T(this,y,e.serialize??((e,t)=>{const r=new p({size:this.serializedSize(e)??void 0,...t});return v(this,m).call(this,e,r),r.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),v(this,m).call(this,e,t)}serialize(e,t){return this.validate(e),new A(this,v(this,y).call(this,e,t))}parse(e){const t=new l(e);return this.read(t)}transform({name:e,input:t,output:r}){return new E({name:e??this.name,read:e=>r(this.read(e)),write:(e,r)=>v(this,m).call(this,t(e),r),serializedSize:e=>this.serializedSize(t(e)),serialize:(e,r)=>v(this,y).call(this,t(e),r),validate:e=>this.validate(t(e))})}};let x=E;m=new WeakMap,y=new WeakMap;const k=Symbol.for("@mysten/serialized-bcs");class A{constructor(e,t){S(this,g,void 0),S(this,w,void 0),T(this,g,e),T(this,w,t)}get[k](){return!0}toBytes(){return v(this,w)}toHex(){return u(v(this,w))}toBase64(){return i(v(this,w))}toBase58(){return a(v(this,w))}parse(){return v(this,g).parse(v(this,w))}}function I({size:e,...t}){return new x({...t,serializedSize:()=>e})}function j({readMethod:e,writeMethod:t,...r}){return I({...r,read:t=>t[e](),write:(e,r)=>r[t](e),validate:e=>{if(e<0||e>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${e}. Expected value in range 0-${r.maxValue}`);r.validate?.(e)}})}function $({readMethod:e,writeMethod:t,...r}){return I({...r,read:t=>t[e](),write:(e,r)=>r[t](BigInt(e)),validate:e=>{const t=BigInt(e);if(t<0||t>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${t}. Expected value in range 0-${r.maxValue}`);r.validate?.(t)}})}g=new WeakMap,w=new WeakMap;class B extends TypeError{constructor(e,t){let r;const{message:n,explanation:i,...s}=e,{path:a}=e,o=0===a.length?n:`At path: ${a.join(".")} -- ${n}`;super(i??o),null!=i&&(this.cause=o),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function M(e){return"object"==typeof e&&null!=e}function O(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function z(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:i,branch:s}=t,{type:a}=r,{refinement:o,message:c=`Expected a value of type \`${a}\`${o?` with refinement \`${o}\``:""}, but received: \`${O(n)}\``}=e;return{value:n,type:a,refinement:o,key:i[i.length-1],path:i,branch:s,...e,message:c}}function*U(e,t,r,n){var i;M(i=e)&&"function"==typeof i[Symbol.iterator]||(e=[e]);for(const i of e){const e=z(i,t,r,n);e&&(yield e)}}function*_(e,t,r={}){const{path:n=[],branch:i=[e],coerce:s=!1,mask:a=!1}=r,o={path:n,branch:i};if(s&&(e=t.coercer(e,o),a&&"type"!==t.type&&M(t.schema)&&M(e)&&!Array.isArray(e)))for(const r in e)void 0===t.schema[r]&&delete e[r];let c="valid";for(const n of t.validator(e,o))n.explanation=r.message,c="not_valid",yield[n,void 0];for(let[u,d,l]of t.entries(e,o)){const t=_(d,l,{path:void 0===u?n:[...n,u],branch:void 0===u?i:[...i,d],coerce:s,mask:a,message:r.message});for(const r of t)r[0]?(c=null!=r[0].refinement?"not_refined":"not_valid",yield[r[0],void 0]):s&&(d=r[1],void 0===u?e=d:e instanceof Map?e.set(u,d):e instanceof Set?e.add(d):M(e)&&(void 0!==d||u in e)&&(e[u]=d))}if("not_valid"!==c)for(const n of t.refiner(e,o))n.explanation=r.message,c="not_refined",yield[n,void 0];"valid"===c&&(yield[void 0,e])}class N{constructor(e){const{type:t,schema:r,validator:n,refiner:i,coercer:s=(e=>e),entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=s,this.validator=n?(e,t)=>U(n(e,t),t,this,e):()=>[],this.refiner=i?(e,t)=>U(i(e,t),t,this,e):()=>[]}assert(e,t){return function(e,t,r){const n=P(e,t,{message:r});if(n[0])throw n[0]}(e,this,t)}create(e,t){return C(e,this,t)}is(e){return V(e,this)}mask(e,t){return function(e,t,r){const n=P(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}(e,this,t)}validate(e,t={}){return P(e,this,t)}}function C(e,t,r){const n=P(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function V(e,t){return!P(e,t)[0]}function P(e,t,r={}){const n=_(e,t,r),i=function(e){const{done:t,value:r}=e.next();return t?void 0:r}(n);return i[0]?[new B(i[0],(function*(){for(const e of n)e[0]&&(yield e[0])})),void 0]:[void 0,i[1]]}function q(e,t){return new N({type:e,schema:null,validator:t})}function R(){return q("any",(()=>!0))}function W(e){return new N({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${O(e)}`})}function L(){return q("integer",(e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${O(e)}`))}function D(e){const t=O(e),r=typeof e;return new N({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${O(r)}`})}function G(e){const t=e?Object.keys(e):[],r=q("never",(()=>!1));return new N({type:"object",schema:e||null,*entries(n){if(e&&M(n)){const i=new Set(Object.keys(n));for(const r of t)i.delete(r),yield[r,n[r],e[r]];for(const e of i)yield[e,n[e],r]}},validator:e=>M(e)||`Expected an object, but received: ${O(e)}`,coercer:e=>M(e)?{...e}:e})}function F(e){return new N({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function K(){return q("string",(e=>"string"==typeof e||`Expected a string, but received: ${O(e)}`))}function J(e){const t=e.map((e=>e.type)).join(" | ");return new N({type:"union",schema:null,coercer(t){for(const r of e){const[e,n]=r.validate(t,{coerce:!0});if(!e)return n}return t},validator(r,n){const i=[];for(const t of e){const[...e]=_(r,t,n),[s]=e;if(!s[0])return[];for(const[t]of e)t&&i.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${O(r)}`,...i]}})}const H=class{constructor(t){if(this.types=new Map,this.counter=0,t instanceof H)return this.schema=t.schema,void(this.types=new Map(t.types));if(this.schema=t,this.registerAddressType(H.ADDRESS,t.addressLength,t.addressEncoding),this.registerVectorType(t.vectorType),t.types&&t.types.structs)for(let e of Object.keys(t.types.structs))this.registerStructType(e,t.types.structs[e]);if(t.types&&t.types.enums)for(let e of Object.keys(t.types.enums))this.registerEnumType(e,t.types.enums[e]);if(t.types&&t.types.aliases)for(let e of Object.keys(t.types.aliases))this.registerAlias(e,t.types.aliases[e]);!1!==t.withPrimitives&&function(t){t.registerType(X.U8,(function(e,t){return e.write8(t)}),(function(e){return e.read8()}),(e=>e<256)),t.registerType(X.U16,(function(e,t){return e.write16(t)}),(function(e){return e.read16()}),(e=>e<65536)),t.registerType(X.U32,(function(e,t){return e.write32(t)}),(function(e){return e.read32()}),(e=>e<=4294967296n)),t.registerType(X.U64,(function(e,t){return e.write64(t)}),(function(e){return e.read64()})),t.registerType(X.U128,(function(e,t){return e.write128(t)}),(function(e){return e.read128()})),t.registerType(X.U256,(function(e,t){return e.write256(t)}),(function(e){return e.read256()})),t.registerType(X.BOOL,(function(e,t){return e.write8(t)}),(function(e){return"1"===e.read8().toString(10)})),t.registerType(X.STRING,(function(e,t){return e.writeVec(Array.from(t),((e,t)=>e.write8(t.charCodeAt(0))))}),(function(e){return e.readVec((e=>e.read8())).map((e=>String.fromCharCode(Number(e)))).join("")}),(e=>!0)),t.registerType(X.HEX,(function(e,t){return e.writeVec(Array.from(c(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return u(new Uint8Array(t))})),t.registerType(X.BASE58,(function(e,t){return e.writeVec(Array.from(o(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return a(new Uint8Array(t))})),t.registerType(X.BASE64,(function(t,r){return t.writeVec(Array.from(e(r)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return i(new Uint8Array(t))}))}(this)}tempKey(){return"bcs-struct-"+ ++this.counter}ser(e,t,r){if("string"==typeof e||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if("object"==typeof e){const n=this.tempKey();return new H(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(e)}`)}de(t,r,n){if("string"==typeof r){if(!n)throw new Error("To pass a string to `bcs.de`, specify encoding");r=function(t,r){switch(r){case"base58":return o(t);case"base64":return e(t);case"hex":return c(t);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(r,n)}if("string"==typeof t||Array.isArray(t)){const{name:e,params:n}=this.parseTypeName(t);return this.getTypeInterface(e).decode(this,r,n)}if("object"==typeof t){const e=new H(this),i=this.tempKey();return e.registerStructType(i,t).de(i,r,n)}throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(t)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r,n=(()=>!0)){const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(e,t,r,n){const i=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return this._encodeRaw.call(e,new p(r),t,n,i)},decode(e,t,r){const n=s.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return this._decodeRaw.call(e,new l(t),r,n)},_encodeRaw(e,r,s,a){if(n(r))return t.call(this,e,r,s,a);throw new Error(`Validation failed for type ${i}, data: ${r}`)},_decodeRaw(e,t,n){return r.call(this,e,t,n)}}),this}registerBcsType(e,t){return this.registerType(e,((e,r,n)=>{const i=n.map((e=>new x({name:String(e),write:(t,r)=>{const{name:i,params:s}=this.parseTypeName(e),a=this.getTypeInterface(i),o=s.reduce(((e,t,r)=>Object.assign(e,{[t]:n[r]})),{});return a._encodeRaw.call(this,r,t,s,o)},read:()=>{throw new Error("Not implemented")}})));return t(...i).write(r,e),e}),((e,r)=>{const n=r.map((e=>new x({name:String(e),write:(e,t)=>{throw new Error("Not implemented")},read:t=>{const{name:n,params:i}=this.parseTypeName(e),s=this.getTypeInterface(n),a=i.reduce(((e,t,n)=>Object.assign(e,{[t]:r[n]})),{});return s._decodeRaw.call(this,t,i,a)}})));return t(...n).read(e)})),this}registerAddressType(t,r,n="hex"){switch(n){case"base64":return this.registerType(t,(function(t,r){return e(r).reduce(((e,t)=>e.write8(t)),t)}),(function(e){return i(e.readBytes(r))}));case"hex":return this.registerType(t,(function(e,t){return c(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return u(e.readBytes(r))}));default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,(function(t,r,n,i){return t.writeVec(r,((t,r)=>{let s=n[0];if(!s)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:a,params:o}=this.parseTypeName(s);if(this.hasType(a))return this.getTypeInterface(a)._encodeRaw.call(this,t,r,o,i);if(!(a in i))throw new Error(`Unable to find a matching type definition for ${a} in vector; make sure you passed a generic`);let{name:c,params:u}=this.parseTypeName(i[a]);return this.getTypeInterface(c)._encodeRaw.call(this,t,r,u,i)}))}),(function(t,r,n){return t.readVec((t=>{let i=r[0];if(!i)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:s,params:a}=this.parseTypeName(i);if(this.hasType(s))return this.getTypeInterface(s)._decodeRaw.call(this,t,a,n);if(!(s in n))throw new Error(`Unable to find a matching type definition for ${s} in vector; make sure you passed a generic`);let{name:o,params:c}=this.parseTypeName(n[s]);return this.getTypeInterface(o)._decodeRaw.call(this,t,c,n)}))}))}registerStructType(e,t){for(let e in t){let r=this.tempKey(),n=t[e];Array.isArray(n)||"string"==typeof n||(t[e]=r,this.registerStructType(r,n))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t||t.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${t}`);if(a.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${a.length}`);for(let c of n){if(!(c in t))throw new Error(`Struct ${i} requires field ${c}:${r[c]}`);const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:d}=this.parseTypeName(a[r]);if(this.hasType(u)){this.getTypeInterface(u)._encodeRaw.call(this,e,t[c],d,o);continue}if(!(u in o))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:l,params:h}=this.parseTypeName(o[u]);this.getTypeInterface(l)._encodeRaw.call(this,e,t[c],h,o)}else this.getTypeInterface(n)._encodeRaw.call(this,e,t[c],u,o)}return e}),(function(e,t,a){if(t.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${t.length}`);let o={};for(let c of n){const{name:n,params:u}=this.parseTypeName(r[c]);if(s.includes(n)){const r=s.indexOf(n);let{name:u,params:d}=this.parseTypeName(t[r]);if(this.hasType(u)){o[c]=this.getTypeInterface(u)._decodeRaw.call(this,e,d,a);continue}if(!(u in a))throw new Error(`Unable to find a matching type definition for ${u} in ${i}; make sure you passed a generic`);let{name:l,params:h}=this.parseTypeName(a[u]);o[c]=this.getTypeInterface(l)._decodeRaw.call(this,e,h,a)}else o[c]=this.getTypeInterface(n)._decodeRaw.call(this,e,u,a)}return o}))}registerEnumType(e,t){for(let e in t){let r=this.tempKey(),n=t[e];null===n||Array.isArray(n)||"string"==typeof n||(t[e]=r,this.registerStructType(r,n))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t)throw new Error(`Unable to write enum "${i}", missing data.\nReceived: "${t}"`);if("object"!=typeof t)throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".\nReceived: "${JSON.stringify(t)}"`);let c=Object.keys(t)[0];if(void 0===c)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let u=n.indexOf(c);if(-1===u)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${c}"`);let d=n[u],l=r[d];if(e.write8(u),null===l)return e;let h=s.indexOf(l),p=-1===h?l:a[h];{let{name:r,params:n}=this.parseTypeName(p);return this.getTypeInterface(r)._encodeRaw.call(this,e,t[c],n,o)}}),(function(e,t,a){let o=e.readULEB(),c=n[o],u=r[c];if(-1===o)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${o}"`);if(null===u)return{[c]:!0};let d=s.indexOf(u),l=-1===d?u:t[d];{let{name:t,params:r}=this.parseTypeName(l);return{[c]:this.getTypeInterface(t)._decodeRaw.call(this,e,r,a)}}}))}getTypeInterface(e){let t=this.types.get(e);if("string"==typeof t){let e=[];for(;"string"==typeof t;){if(e.includes(t))throw new Error(`Recursive definition found: ${e.join(" -> ")} -> ${t}`);e.push(t),t=this.types.get(t)}}if(void 0===t)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[t,...r]=e;return{name:t,params:r}}if("string"!=typeof e)throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(-1===n&&-1===i)return{name:e,params:[]};if(-1===n||-1===i)throw new Error(`Unclosed generic in name '${e}'`);return{name:e.slice(0,n),params:h(e.slice(n+1,e.length-i-1),this.schema.genericSeparators)}}};let X=H;X.U8="u8",X.U16="u16",X.U32="u32",X.U64="u64",X.U128="u128",X.U256="u256",X.BOOL="bool",X.VECTOR="vector",X.ADDRESS="address",X.STRING="string",X.HEX="hex-string",X.BASE58="base58-string",X.BASE64="base64-string";const Z={u8:e=>j({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:255,...e}),u16:e=>j({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:65535,...e}),u32:e=>j({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e}),u64:e=>$({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e}),u128:e=>$({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e}),u256:e=>$({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e}),bool:e=>I({name:"bool",size:1,read:e=>1===e.read8(),write:(e,t)=>t.write8(e?1:0),...e,validate:t=>{if(e?.validate?.(t),"boolean"!=typeof t)throw new TypeError("Expected boolean, found "+typeof t)}}),uleb128:e=>function({serialize:e,...t}){const r=new x({...t,serialize:e,write:(e,t)=>{for(const n of r.serialize(e).toBytes())t.write8(n)}});return r}({name:"uleb128",read:e=>e.readULEB(),serialize:e=>Uint8Array.from(d(e)),...e}),bytes:(e,t)=>I({name:`bytes[${e}]`,size:e,read:t=>t.readBytes(e),write:(t,r)=>{for(let n=0;n<e;n++)r.write8(t[n]??0)},...t,validate:r=>{if(t?.validate?.(r),!("length"in r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}}),string:e=>function({toBytes:e,fromBytes:t,...r}){return new x({...r,read:e=>{const r=e.readULEB(),n=e.readBytes(r);return t(n)},write:(t,r)=>{const n=e(t);r.writeULEB(n.length);for(let e=0;e<n.length;e++)r.write8(n[e])},serialize:t=>{const r=e(t),n=d(r.length),i=new Uint8Array(n.length+r.length);return i.set(n,0),i.set(r,n.length),i},validate:e=>{if("string"!=typeof e)throw new TypeError(`Invalid ${r.name} value: ${e}. Expected string`);r.validate?.(e)}})}({name:"string",toBytes:e=>(new TextEncoder).encode(e),fromBytes:e=>(new TextDecoder).decode(e),...e}),fixedArray:(e,t,r)=>new x({name:`${t.name}[${e}]`,read:r=>{const n=new Array(e);for(let i=0;i<e;i++)n[i]=t.read(r);return n},write:(e,r)=>{for(const n of e)t.write(n,r)},...r,validate:t=>{if(r?.validate?.(t),!("length"in t))throw new TypeError("Expected array, found "+typeof t);if(t.length!==e)throw new TypeError(`Expected array of length ${e}, found ${t.length}`)}}),option:e=>Z.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:e=>null==e?{None:!0}:{Some:e},output:e=>"Some"in e?e.Some:null}),vector:(e,t)=>new x({name:`vector<${e.name}>`,read:t=>{const r=t.readULEB(),n=new Array(r);for(let i=0;i<r;i++)n[i]=e.read(t);return n},write:(t,r)=>{r.writeULEB(t.length);for(const n of t)e.write(n,r)},...t,validate:e=>{if(t?.validate?.(e),!("length"in e))throw new TypeError("Expected array, found "+typeof e)}}),tuple:(e,t)=>new x({name:`(${e.map((e=>e.name)).join(", ")})`,serializedSize:t=>{let r=0;for(let n=0;n<e.length;n++){const i=e[n].serializedSize(t[n]);if(null==i)return null;r+=i}return r},read:t=>{const r=[];for(const n of e)r.push(n.read(t));return r},write:(t,r)=>{for(let n=0;n<e.length;n++)e[n].write(t[n],r)},...t,validate:r=>{if(t?.validate?.(r),!Array.isArray(r))throw new TypeError("Expected array, found "+typeof r);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}}),struct(e,t,r){const n=Object.entries(t);return new x({name:e,serializedSize:e=>{let t=0;for(const[r,i]of n){const n=i.serializedSize(e[r]);if(null==n)return null;t+=n}return t},read:e=>{const t={};for(const[r,i]of n)t[r]=i.read(e);return t},write:(e,t)=>{for(const[r,i]of n)i.write(e[r],t)},...r,validate:e=>{if(r?.validate?.(e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e)}})},enum(e,t,r){const n=Object.entries(t);return new x({name:e,read:e=>{const t=e.readULEB(),[r,i]=n[t];return{[r]:i?.read(e)??!0}},write:(e,t)=>{const[r,i]=Object.entries(e)[0];for(let e=0;e<n.length;e++){const[s,a]=n[e];if(s===r)return t.writeULEB(e),void a?.write(i,t)}},...r,validate:e=>{if(r?.validate?.(e),"object"!=typeof e||null==e)throw new TypeError("Expected object, found "+typeof e);const n=Object.keys(e);if(1!==n.length)throw new TypeError(`Expected object with one key, found ${n.length}`);const[i]=n;if(!Object.hasOwn(t,i))throw new TypeError(`Invalid enum variant ${i}`)}})},map:(e,t)=>Z.vector(Z.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:e=>[...e.entries()],output:e=>{const t=new Map;for(const[r,n]of e)t.set(r,n);return t}}),generic:(e,t)=>(...e)=>t(...e).transform({name:`${t.name}<${e.map((e=>e.name)).join(", ")}>`,input:e=>e,output:e=>e}),lazy:e=>function(e){let t=null;function r(){return t||(t=e()),t}return new x({name:"lazy",read:e=>r().read(e),serializedSize:e=>r().serializedSize(e),write:(e,t)=>r().write(e,t),serialize:(e,t)=>r().serialize(e,t).toBytes()})}(e)};function Q(e){try{return 32===o(e).length}catch(e){return!1}}const Y=32;function ee(e){return function(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2==0}(e)&&function(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}(e)===Y}function te(e){return ee(e)}function re(e,t=!1){let r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(2*Y,"0")}`}function ne(e,t=!1){return re(e,t)}const ie=/^vector<(.+)>$/,se=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class ae{static parseFromStr(e,t=!1){if("address"===e)return{address:null};if("bool"===e)return{bool:null};if("u8"===e)return{u8:null};if("u16"===e)return{u16:null};if("u32"===e)return{u32:null};if("u64"===e)return{u64:null};if("u128"===e)return{u128:null};if("u256"===e)return{u256:null};if("signer"===e)return{signer:null};const r=e.match(ie);if(r)return{vector:ae.parseFromStr(r[1],t)};const n=e.match(se);if(n)return{struct:{address:t?re(n[1]):n[1],module:n[2],name:n[3],typeParams:void 0===n[5]?[]:ae.parseStructTypeArgs(n[5],t)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,t=!1){return h(e).map((e=>ae.parseFromStr(e,t)))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${ae.tagToString(e.vector)}>`;if("struct"in e){const t=e.struct,r=t.typeParams.map(ae.tagToString).join(", ");return`${t.address}::${t.module}::${t.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}const oe=new X({genericSeparators:["<",">"],vectorType:"vector",addressLength:32,addressEncoding:"hex",types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function ce(e){return Z.u64({name:"unsafe_u64",...e}).transform({input:e=>e,output:e=>Number(e)})}function ue(e){return e.transform({input:e=>({[e.kind]:e}),output:e=>{const t=Object.keys(e)[0];return{kind:t,...e[t]}}})}const de=Z.bytes(Y).transform({input:e=>"string"==typeof e?c(re(e)):e,output:e=>re(u(e))}),le=Z.vector(Z.u8()).transform({name:"ObjectDigest",input:e=>o(e),output:e=>a(new Uint8Array(e))}),he=Z.struct("SuiObjectRef",{objectId:de,version:Z.u64(),digest:le}),pe=Z.struct("SharedObjectRef",{objectId:de,initialSharedVersion:Z.u64(),mutable:Z.bool()}),fe=Z.enum("ObjectArg",{ImmOrOwned:he,Shared:pe,Receiving:he}),me=Z.enum("CallArg",{Pure:Z.vector(Z.u8()),Object:fe,ObjVec:Z.vector(fe)}),ye=Z.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:Z.lazy((()=>ye)),struct:Z.lazy((()=>Ee)),u16:null,u32:null,u256:null}),ge=ue(Z.enum("Argument",{GasCoin:null,Input:Z.struct("Input",{index:Z.u16()}),Result:Z.struct("Result",{index:Z.u16()}),NestedResult:Z.struct("NestedResult",{index:Z.u16(),resultIndex:Z.u16()})})),we=Z.struct("ProgrammableMoveCall",{package:de,module:Z.string(),function:Z.string(),type_arguments:Z.vector(ye),arguments:Z.vector(ge)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map((e=>ae.parseFromStr(e,!0)));return{package:re(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(ae.tagToString)})}),be=ue(Z.enum("Transaction",{MoveCall:we,TransferObjects:Z.struct("TransferObjects",{objects:Z.vector(ge),address:ge}),SplitCoins:Z.struct("SplitCoins",{coin:ge,amounts:Z.vector(ge)}),MergeCoins:Z.struct("MergeCoins",{destination:ge,sources:Z.vector(ge)}),Publish:Z.struct("Publish",{modules:Z.vector(Z.vector(Z.u8())),dependencies:Z.vector(de)}),MakeMoveVec:Z.struct("MakeMoveVec",{type:(Re=ye,Z.enum("Option",{None:null,Some:Re})),objects:Z.vector(ge)}),Upgrade:Z.struct("Upgrade",{modules:Z.vector(Z.vector(Z.u8())),dependencies:Z.vector(de),packageId:de,ticket:ge})})),ve=Z.struct("ProgrammableTransaction",{inputs:Z.vector(me),transactions:Z.vector(be)}),Se=Z.enum("TransactionKind",{ProgrammableTransaction:ve,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),Te=Z.enum("TransactionExpiration",{None:null,Epoch:ce()}),Ee=Z.struct("StructTag",{address:de,module:Z.string(),name:Z.string(),typeParams:Z.vector(ye)}),xe=Z.struct("GasData",{payment:Z.vector(he),owner:de,price:Z.u64(),budget:Z.u64()}),ke=Z.struct("TransactionDataV1",{kind:Se,sender:de,gasData:xe,expiration:Te}),Ae=Z.enum("TransactionData",{V1:ke}),Ie=Z.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),je=Z.enum("IntentVersion",{V0:null}),$e=Z.enum("AppId",{Sui:null}),Be=Z.struct("Intent",{scope:Ie,version:je,appId:$e}),Me=Z.generic(["T"],(e=>Z.struct("IntentMessage<T>",{intent:Be,value:e}))),Oe=Z.enum("CompressedSignature",{ED25519:Z.fixedArray(64,Z.u8()),Secp256k1:Z.fixedArray(64,Z.u8()),Secp256r1:Z.fixedArray(64,Z.u8()),ZkLogin:Z.vector(Z.u8())}),ze=Z.enum("PublicKey",{ED25519:Z.fixedArray(32,Z.u8()),Secp256k1:Z.fixedArray(33,Z.u8()),Secp256r1:Z.fixedArray(33,Z.u8()),ZkLogin:Z.vector(Z.u8())}),Ue=Z.struct("MultiSigPkMap",{pubKey:ze,weight:Z.u8()}),_e=Z.struct("MultiSigPublicKey",{pk_map:Z.vector(Ue),threshold:Z.u16()}),Ne=Z.struct("MultiSig",{sigs:Z.vector(Oe),bitmap:Z.u16(),multisig_pk:_e}),Ce=Z.vector(Z.u8()).transform({input:t=>"string"==typeof t?e(t):t,output:e=>i(new Uint8Array(e))}),Ve=Z.struct("SenderSignedTransaction",{intentMessage:Me(Ae),txSignatures:Z.vector(Ce)}),Pe=Z.vector(Ve,{name:"SenderSignedData"}),qe={...Z,U8:Z.u8(),U16:Z.u16(),U32:Z.u32(),U64:Z.u64(),U128:Z.u128(),U256:Z.u256(),ULEB128:Z.uleb128(),Bool:Z.bool(),String:Z.string(),Address:de,Argument:ge,CallArg:me,CompressedSignature:Oe,GasData:xe,MultiSig:Ne,MultiSigPkMap:Ue,MultiSigPublicKey:_e,ObjectArg:fe,ObjectDigest:le,ProgrammableMoveCall:we,ProgrammableTransaction:ve,PublicKey:ze,SenderSignedData:Pe,SenderSignedTransaction:Ve,SharedObjectRef:pe,StructTag:Ee,SuiObjectRef:he,Transaction:be,TransactionData:Ae,TransactionDataV1:ke,TransactionExpiration:Te,TransactionKind:Se,TypeTag:ye,ser:oe.ser.bind(oe),de:oe.de.bind(oe),getTypeInterface:oe.getTypeInterface.bind(oe),hasType:oe.hasType.bind(oe),parseTypeName:oe.parseTypeName.bind(oe),registerAddressType:oe.registerAddressType.bind(oe),registerAlias:oe.registerAlias.bind(oe),registerBcsType:oe.registerBcsType.bind(oe),registerEnumType:oe.registerEnumType.bind(oe),registerStructType:oe.registerStructType.bind(oe),registerType:oe.registerType.bind(oe),types:oe.types};var Re;oe.registerBcsType("utf8string",(()=>Z.string({name:"utf8string"}))),oe.registerBcsType("unsafe_u64",(()=>ce())),oe.registerBcsType("enumKind",(e=>ue(e))),[de,ge,me,Oe,xe,Ne,Ue,_e,fe,le,we,ve,ze,Pe,pe,Ee,he,be,Ae,ke,Te,Se,ye].forEach((e=>{oe.registerBcsType(e.name,(()=>e))})),BigInt(1e9);const We="0x1",Le=(ne("0x6"),ne("0x5"),G({digest:K(),objectId:K(),version:J([q("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${O(e)}`)),K(),q("bigint",(e=>"bigint"==typeof e))])})),De=J([G({ImmOrOwned:Le}),G({Shared:G({objectId:K(),initialSharedVersion:J([L(),K()]),mutable:q("boolean",(e=>"boolean"==typeof e))})}),G({Receiving:Le})]),Ge=G({Pure:W(L())}),Fe=G({Object:De}),Ke=J([Ge,Fe]),Je=function(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:(r=e,r&&"object"==typeof r&&!0===r[k]?e.toBytes():qe.ser(t,e,{maxSize:1/0}).toBytes()))};var r},He=({objectId:e,digest:t,version:r})=>({Object:{ImmOrOwned:{digest:t,version:r,objectId:re(e)}}}),Xe=({objectId:e,mutable:t,initialSharedVersion:r})=>({Object:{Shared:{mutable:t,initialSharedVersion:r,objectId:re(e)}}}),Ze=({objectId:e,digest:t,version:r})=>({Object:{Receiving:{digest:t,version:r,objectId:re(e)}}});function Qe(e){return"object"==typeof e&&"MutableReference"in e?e.MutableReference:void 0}function Ye(e){return"object"==typeof e&&"Reference"in e?e.Reference:void 0}function et(e){if("object"==typeof e&&"Struct"in e)return e;const t=Ye(e),r=Qe(e);return"object"==typeof t&&"Struct"in t?t:"object"==typeof r&&"Struct"in r?r:void 0}const tt={address:"0x2",module:"object",name:"ID"},rt={address:We,module:"ascii",name:"String"},nt={address:We,module:"string",name:"String"},it={address:We,module:"option",name:"Option"},st=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function at(e,t){if(void 0!==t&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const ot=["Address","Bool","U8","U16","U32","U64","U128","U256"];function ct(e,t){if("string"==typeof e&&ot.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])at("number",t);else if("Bool"===e)at("boolean",t);else if("Address"===e&&(at("string",t),t&&!ee(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}if("string"==typeof e)throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((void 0===t||"string"==typeof t)&&"U8"===e.Vector)return"string";if(void 0!==t&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=ct(e.Vector,t?t[0]:void 0);if(void 0===r)return;return`vector<${r}>`}if("Struct"in e){if(st(e.Struct,rt))return"string";if(st(e.Struct,nt))return"utf8string";if(st(e.Struct,tt))return"address";if(st(e.Struct,it))return ct({Vector:e.Struct.typeArguments[0]},t)}}const ut=J([G({kind:D("Input"),index:L(),value:F(R()),type:F(D("object"))}),G({kind:D("Input"),index:L(),value:F(R()),type:D("pure")})]),dt=J([ut,G({kind:D("GasCoin")}),G({kind:D("Result"),index:L()}),G({kind:D("NestedResult"),index:L(),resultIndex:L()})]),lt=G({kind:D("MoveCall"),target:q("target",K().validator),typeArguments:W(K()),arguments:W(dt)}),ht=G({kind:D("TransferObjects"),objects:W(dt),address:dt}),pt=G({kind:D("SplitCoins"),coin:dt,amounts:W(dt)}),ft=G({kind:D("MergeCoins"),destination:dt,sources:W(dt)}),mt=G({kind:D("MakeMoveVec"),type:F((gt=K(),wt=q("unknown",(()=>!0)),yt=new N({type:"record",schema:null,*entries(e){if(M(e))for(const t in e){const r=e[t];yield[t,t,gt],yield[t,r,wt]}},validator:e=>M(e)||`Expected an object, but received: ${O(e)}`}),J([G({None:J([D(!0),D(null)])}),G({Some:yt})]))),objects:W(dt)});var yt,gt,wt;J([...[lt,ht,pt,ft,G({kind:D("Publish"),modules:W(W(L())),dependencies:W(K())}),G({kind:D("Upgrade"),modules:W(W(L())),dependencies:W(K()),packageId:K(),ticket:dt}),mt]]);var bt,vt,St,Tt=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},Et=(e,t,r)=>(Tt(e,t,"read from private field"),r?r.call(e):t.get(e)),xt=(e,t,r)=>(Tt(e,t,"access private method"),r);const kt={maxPureArgumentSize:16384,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:131072};function At(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const It=Symbol.for("@mysten/transaction"),jt={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"};bt=new WeakMap,new WeakSet,new WeakSet,vt=new WeakSet,St=function(e,{protocolConfig:t,limits:r}){if(r&&"number"==typeof r[e])return r[e];if(!t)return kt[e];const n=t?.attributes[jt[e]];if(!n)throw new Error(`Missing expected protocol config: "${jt[e]}"`);const i="u64"in n?n.u64:"u32"in n?n.u32:n.f64;if(!i)throw new Error(`Unexpected protocol config value found for: "${jt[e]}"`);return Number(i)},new WeakSet,new WeakSet,new WeakSet,new WeakSet,new WeakSet;const $t=/^(?:[a-z0-9][a-z0-9-]{0,62}(?:\.[a-z0-9][a-z0-9-]{0,62})*)?@[a-z0-9][a-z0-9-]{0,62}$/i,Bt=/^(?:[a-z0-9][a-z0-9-]{0,62}\.)+sui$/i,Mt={"-32700":"ParseError","-32600":"InvalidRequest","-32601":"MethodNotFound","-32602":"InvalidParams","-32603":"InternalError"};class Ot extends Error{}class zt extends Ot{constructor(e,t){super(e),this.code=t,this.type=Mt[t]??"ServerError"}}class Ut extends Ot{constructor(e,t,r){super(e),this.status=t,this.statusText=r}}var _t,Nt,Ct,Vt,Pt,qt,Rt,Wt,Lt,Dt,Gt=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},Ft=(e,t,r)=>(Gt(e,t,"read from private field"),r?r.call(e):t.get(e)),Kt=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Jt=(e,t,r,n)=>(Gt(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r),Ht=(e,t,r)=>(Gt(e,t,"access private method"),r);const Xt={WebSocketConstructor:"undefined"!=typeof WebSocket?WebSocket:void 0,callTimeout:3e4,reconnectTimeout:3e3,maxReconnects:5};class Zt{constructor(e,t={}){if(Kt(this,Rt),Kt(this,Lt),Kt(this,_t,0),Kt(this,Nt,0),Kt(this,Ct,null),Kt(this,Vt,null),Kt(this,Pt,new Set),Kt(this,qt,new Map),this.endpoint=e,this.options={...Xt,...t},!this.options.WebSocketConstructor)throw new Error("Missing WebSocket constructor");this.endpoint.startsWith("http")&&(this.endpoint=function(e){const t=new URL(e);return t.protocol=t.protocol.replace("http","ws"),t.toString()}(this.endpoint))}async makeRequest(e,t){const r=await Ht(this,Rt,Wt).call(this);return new Promise(((n,i)=>{Jt(this,_t,Ft(this,_t)+1),Ft(this,qt).set(Ft(this,_t),{resolve:n,reject:i,timeout:setTimeout((()=>{Ft(this,qt).delete(Ft(this,_t)),i(new Error(`Request timeout: ${e}`))}),this.options.callTimeout)}),r.send(JSON.stringify({jsonrpc:"2.0",id:Ft(this,_t),method:e,params:t}))})).then((({error:e,result:t})=>{if(e)throw new zt(e.message,e.code);return t}))}async subscribe(e){const t=new Qt(e);return Ft(this,Pt).add(t),await t.subscribe(this),()=>t.unsubscribe(this)}}_t=new WeakMap,Nt=new WeakMap,Ct=new WeakMap,Vt=new WeakMap,Pt=new WeakMap,qt=new WeakMap,Rt=new WeakSet,Wt=function(){return Ft(this,Vt)||Jt(this,Vt,new Promise((e=>{Ft(this,Ct)?.close(),Jt(this,Ct,new this.options.WebSocketConstructor(this.endpoint)),Ft(this,Ct).addEventListener("open",(()=>{Jt(this,Nt,0),e(Ft(this,Ct))})),Ft(this,Ct).addEventListener("close",(()=>{var e,t;(e=this,t=Nt,{set _(r){Jt(e,t,r,undefined)},get _(){return Ft(e,t,undefined)}})._++,Ft(this,Nt)<=this.options.maxReconnects&&setTimeout((()=>{Ht(this,Lt,Dt).call(this)}),this.options.reconnectTimeout)})),Ft(this,Ct).addEventListener("message",(({data:e})=>{let t;try{t=JSON.parse(e)}catch(t){return void console.error(new Error(`Failed to parse RPC message: ${e}`,{cause:t}))}if("id"in t&&null!=t.id&&Ft(this,qt).has(t.id)){const{resolve:e,timeout:r}=Ft(this,qt).get(t.id);clearTimeout(r),e(t)}else if("params"in t){const{params:e}=t;Ft(this,Pt).forEach((t=>{t.subscriptionId===e.subscription&&e.subscription===t.subscriptionId&&t.onMessage(e.result)}))}}))}))),Ft(this,Vt)},Lt=new WeakSet,Dt=async function(){return Ft(this,Ct)?.close(),Jt(this,Vt,null),Promise.allSettled([...Ft(this,Pt)].map((e=>e.subscribe(this))))};class Qt{constructor(e){this.subscriptionId=null,this.subscribed=!1,this.input=e}onMessage(e){this.subscribed&&this.input.onMessage(e)}async unsubscribe(e){const{subscriptionId:t}=this;return this.subscribed=!1,null!=t&&(this.subscriptionId=null,e.makeRequest(this.input.unsubscribe,[t]))}async subscribe(e){this.subscriptionId=null,this.subscribed=!0;const t=await e.makeRequest(this.input.method,this.input.params);this.subscribed&&(this.subscriptionId=t)}}var Yt,er,tr,rr,nr,ir=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},sr=(e,t,r)=>(ir(e,t,"read from private field"),r?r.call(e):t.get(e)),ar=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},or=(e,t,r,n)=>(ir(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r);class cr{constructor(e){ar(this,rr),ar(this,Yt,0),ar(this,er,void 0),ar(this,tr,void 0),or(this,er,e)}fetch(e,t){const r=sr(this,er).fetch??globalThis.fetch;if(!r)throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");return r(e,t)}async request(e){or(this,Yt,sr(this,Yt)+1);const t=await this.fetch(sr(this,er).rpc?.url??sr(this,er).url,{method:"POST",headers:{"Content-Type":"application/json","Client-Sdk-Type":"typescript","Client-Sdk-Version":"0.54.1","Client-Target-Api-Version":"1.25.0",...sr(this,er).rpc?.headers},body:JSON.stringify({jsonrpc:"2.0",id:sr(this,Yt),method:e.method,params:e.params})});if(!t.ok)throw new Ut(`Unexpected status code: ${t.status}`,t.status,t.statusText);const r=await t.json();if("error"in r&&null!=r.error)throw new zt(r.error.message,r.error.code);return r.result}async subscribe(e){const t=await(r=rr,n=nr,ir(this,r,"access private method"),n).call(this).subscribe(e);var r,n;return async()=>!!await t()}}Yt=new WeakMap,er=new WeakMap,tr=new WeakMap,rr=new WeakSet,nr=function(){if(!sr(this,tr)){const e=sr(this,er).WebSocketConstructor??globalThis.WebSocket;if(!e)throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");or(this,tr,new Zt(sr(this,er).websocket?.url??sr(this,er).url,{WebSocketConstructor:e,...sr(this,er).websocket}))}return sr(this,tr)};const ur=Symbol.for("@mysten/SuiClient");var dr=new class{get[ur](){return!0}constructor(e){this.transport=e.transport??new cr({url:e.url})}async getRpcApiVersion(){return(await this.transport.request({method:"rpc.discover",params:[]})).info.version}async getCoins(e){if(!e.owner||!ee(re(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getCoins",params:[e.owner,e.coinType,e.cursor,e.limit]})}async getAllCoins(e){if(!e.owner||!ee(re(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllCoins",params:[e.owner,e.cursor,e.limit]})}async getBalance(e){if(!e.owner||!ee(re(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getBalance",params:[e.owner,e.coinType]})}async getAllBalances(e){if(!e.owner||!ee(re(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllBalances",params:[e.owner]})}async getCoinMetadata(e){return await this.transport.request({method:"suix_getCoinMetadata",params:[e.coinType]})}async getTotalSupply(e){return await this.transport.request({method:"suix_getTotalSupply",params:[e.coinType]})}async call(e,t){return await this.transport.request({method:e,params:t})}async getMoveFunctionArgTypes(e){return await this.transport.request({method:"sui_getMoveFunctionArgTypes",params:[e.package,e.module,e.function]})}async getNormalizedMoveModulesByPackage(e){return await this.transport.request({method:"sui_getNormalizedMoveModulesByPackage",params:[e.package]})}async getNormalizedMoveModule(e){return await this.transport.request({method:"sui_getNormalizedMoveModule",params:[e.package,e.module]})}async getNormalizedMoveFunction(e){return await this.transport.request({method:"sui_getNormalizedMoveFunction",params:[e.package,e.module,e.function]})}async getNormalizedMoveStruct(e){return await this.transport.request({method:"sui_getNormalizedMoveStruct",params:[e.package,e.module,e.struct]})}async getOwnedObjects(e){if(!e.owner||!ee(re(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getOwnedObjects",params:[e.owner,{filter:e.filter,options:e.options},e.cursor,e.limit]})}async getObject(e){if(!e.id||!te(ne(e.id)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"sui_getObject",params:[e.id,e.options]})}async tryGetPastObject(e){return await this.transport.request({method:"sui_tryGetPastObject",params:[e.id,e.version,e.options]})}async multiGetObjects(e){if(e.ids.forEach((e=>{if(!e||!te(ne(e)))throw new Error(`Invalid Sui Object id ${e}`)})),e.ids.length!==new Set(e.ids).size)throw new Error(`Duplicate object ids in batch call ${e.ids}`);return await this.transport.request({method:"sui_multiGetObjects",params:[e.ids,e.options]})}async queryTransactionBlocks(e){return await this.transport.request({method:"suix_queryTransactionBlocks",params:[{filter:e.filter,options:e.options},e.cursor,e.limit,"descending"===(e.order||"descending")]})}async getTransactionBlock(e){if(!Q(e.digest))throw new Error("Invalid Transaction digest");return await this.transport.request({method:"sui_getTransactionBlock",params:[e.digest,e.options]})}async multiGetTransactionBlocks(e){if(e.digests.forEach((e=>{if(!Q(e))throw new Error(`Invalid Transaction digest ${e}`)})),e.digests.length!==new Set(e.digests).size)throw new Error(`Duplicate digests in batch call ${e.digests}`);return await this.transport.request({method:"sui_multiGetTransactionBlocks",params:[e.digests,e.options]})}async executeTransactionBlock(e){return await this.transport.request({method:"sui_executeTransactionBlock",params:["string"==typeof e.transactionBlock?e.transactionBlock:i(e.transactionBlock),Array.isArray(e.signature)?e.signature:[e.signature],e.options,e.requestType]})}async signAndExecuteTransactionBlock({transactionBlock:e,signer:t,...r}){let n;e instanceof Uint8Array?n=e:(e.setSenderIfNotSet(t.toSuiAddress()),n=await e.build({client:this}));const{signature:i,bytes:s}=await t.signTransactionBlock(n);return this.executeTransactionBlock({transactionBlock:s,signature:i,...r})}async getTotalTransactionBlocks(){const e=await this.transport.request({method:"sui_getTotalTransactionBlocks",params:[]});return BigInt(e)}async getReferenceGasPrice(){const e=await this.transport.request({method:"suix_getReferenceGasPrice",params:[]});return BigInt(e)}async getStakes(e){if(!e.owner||!ee(re(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getStakes",params:[e.owner]})}async getStakesByIds(e){return e.stakedSuiIds.forEach((e=>{if(!e||!te(ne(e)))throw new Error(`Invalid Sui Stake id ${e}`)})),await this.transport.request({method:"suix_getStakesByIds",params:[e.stakedSuiIds]})}async getLatestSuiSystemState(){return await this.transport.request({method:"suix_getLatestSuiSystemState",params:[]})}async queryEvents(e){return await this.transport.request({method:"suix_queryEvents",params:[e.query,e.cursor,e.limit,"descending"===(e.order||"descending")]})}async subscribeEvent(e){return this.transport.subscribe({method:"suix_subscribeEvent",unsubscribe:"suix_unsubscribeEvent",params:[e.filter],onMessage:e.onMessage})}async subscribeTransaction(e){return this.transport.subscribe({method:"suix_subscribeTransaction",unsubscribe:"suix_unsubscribeTransaction",params:[e.filter],onMessage:e.onMessage})}async devInspectTransactionBlock(e){let t;if((r=e.transactionBlock)&&"object"==typeof r&&!0===r[It])e.transactionBlock.setSenderIfNotSet(e.sender),t=i(await e.transactionBlock.build({client:this,onlyTransactionKind:!0}));else if("string"==typeof e.transactionBlock)t=e.transactionBlock;else{if(!(e.transactionBlock instanceof Uint8Array))throw new Error("Unknown transaction block format.");t=i(e.transactionBlock)}var r;return await this.transport.request({method:"sui_devInspectTransactionBlock",params:[e.sender,t,e.gasPrice?.toString(),e.epoch]})}async dryRunTransactionBlock(e){return await this.transport.request({method:"sui_dryRunTransactionBlock",params:["string"==typeof e.transactionBlock?e.transactionBlock:i(e.transactionBlock)]})}async getDynamicFields(e){if(!e.parentId||!te(ne(e.parentId)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"suix_getDynamicFields",params:[e.parentId,e.cursor,e.limit]})}async getDynamicFieldObject(e){return await this.transport.request({method:"suix_getDynamicFieldObject",params:[e.parentId,e.name]})}async getLatestCheckpointSequenceNumber(){const e=await this.transport.request({method:"sui_getLatestCheckpointSequenceNumber",params:[]});return String(e)}async getCheckpoint(e){return await this.transport.request({method:"sui_getCheckpoint",params:[e.id]})}async getCheckpoints(e){return await this.transport.request({method:"sui_getCheckpoints",params:[e.cursor,e?.limit,e.descendingOrder]})}async getCommitteeInfo(e){return await this.transport.request({method:"suix_getCommitteeInfo",params:[e?.epoch]})}async getNetworkMetrics(){return await this.transport.request({method:"suix_getNetworkMetrics",params:[]})}async getAddressMetrics(){return await this.transport.request({method:"suix_getLatestAddressMetrics",params:[]})}async getEpochMetrics(e){return await this.transport.request({method:"suix_getEpochMetrics",params:[e?.cursor,e?.limit,e?.descendingOrder]})}async getAllEpochAddressMetrics(e){return await this.transport.request({method:"suix_getAllEpochAddressMetrics",params:[e?.descendingOrder]})}async getEpochs(e){return await this.transport.request({method:"suix_getEpochs",params:[e?.cursor,e?.limit,e?.descendingOrder]})}async getMoveCallMetrics(){return await this.transport.request({method:"suix_getMoveCallMetrics",params:[]})}async getCurrentEpoch(){return await this.transport.request({method:"suix_getCurrentEpoch",params:[]})}async getValidatorsApy(){return await this.transport.request({method:"suix_getValidatorsApy",params:[]})}async getChainIdentifier(){const e=await this.getCheckpoint({id:"0"});return u(o(e.digest).slice(0,4))}async resolveNameServiceAddress(e){return await this.transport.request({method:"suix_resolveNameServiceAddress",params:[e.name]})}async resolveNameServiceNames({format:e="dot",...t}){const{nextCursor:r,hasNextPage:n,data:i}=await this.transport.request({method:"suix_resolveNameServiceNames",params:[t.address,t.cursor,t.limit]});return{hasNextPage:n,nextCursor:r,data:i.map((t=>function(e,t="at"){const r=e.toLowerCase();let n;if(r.includes("@")){if(!$t.test(r))throw new Error(`Invalid SuiNS name ${e}`);const[t,i]=r.split("@");n=[...t?t.split("."):[],i]}else{if(!Bt.test(r))throw new Error(`Invalid SuiNS name ${e}`);n=r.split(".").slice(0,-1)}return"dot"===t?`${n.join(".")}.sui`:`${n.slice(0,-1).join(".")}@${n[n.length-1]}`}(t,e)))}}async getProtocolConfig(e){return await this.transport.request({method:"sui_getProtocolConfig",params:[e?.version]})}async waitForTransactionBlock({signal:e,timeout:t=6e4,pollInterval:r=2e3,...n}){const i=AbortSignal.timeout(t),s=new Promise(((e,t)=>{i.addEventListener("abort",(()=>t(i.reason)))}));for(s.catch((()=>{}));!i.aborted;){e?.throwIfAborted();try{return await this.getTransactionBlock(n)}catch(e){await Promise.race([new Promise((e=>setTimeout(e,r))),s])}}throw i.throwIfAborted(),new Error("Unexpected error while waiting for transaction block.")}}({url:function(e){switch(e){case"mainnet":return"https://fullnode.mainnet.sui.io:443";case"testnet":return"https://fullnode.testnet.sui.io:443";case"devnet":return"https://fullnode.devnet.sui.io:443";case"localnet":return"http://127.0.0.1:9000";default:throw new Error(`Unknown network: ${e}`)}}("testnet")});function lr(){return dr}})(),n})()));